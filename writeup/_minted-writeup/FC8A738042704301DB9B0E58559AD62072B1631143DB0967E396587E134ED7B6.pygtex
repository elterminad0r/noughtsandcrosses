\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Implementation of the special case of the minmax algorithm, suited to noughts}
\PYG{l+s+sd}{and crosses.}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{from} \PYG{n+nn}{textwrap} \PYG{k+kn}{import} \PYG{n}{indent}
\PYG{k+kn}{from} \PYG{n+nn}{traceback} \PYG{k+kn}{import} \PYG{n}{extract\PYGZus{}stack}

\PYG{k+kn}{from} \PYG{n+nn}{base} \PYG{k+kn}{import} \PYG{n}{Win}
\PYG{k+kn}{from} \PYG{n+nn}{checking} \PYG{k+kn}{import} \PYG{n}{State}\PYG{p}{,} \PYG{n}{is\PYGZus{}run}
\PYG{k+kn}{from} \PYG{n+nn}{formatting} \PYG{k+kn}{import} \PYG{n}{print\PYGZus{}board}\PYG{p}{,} \PYG{n}{strfboard}\PYG{p}{,} \PYG{n}{syms}
\PYG{k+kn}{from} \PYG{n+nn}{interface} \PYG{k+kn}{import} \PYG{n}{SquareBoard}\PYG{p}{,} \PYG{n}{isqrt}

\PYG{k+kn}{from} \PYG{n+nn}{argparse} \PYG{k+kn}{import} \PYG{n}{ArgumentParser}

\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}args}\PYG{p}{():}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Get arguments if a demo run is being executed. A demo run will just}
\PYG{l+s+sd}{    determine the move to be used against a preset board, verbosely by default.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{parser} \PYG{o}{=} \PYG{n}{ArgumentParser}\PYG{p}{(}\PYG{n}{description}\PYG{o}{=}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}}\PYG{p}{)}
    \PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZhy{}b\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}\PYGZhy{}\PYGZhy{}board\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{type}\PYG{o}{=}\PYG{n}{SquareBoard}\PYG{p}{,} \PYG{n}{default}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}o\PYGZus{}\PYGZus{}x\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZsq{}}\PYG{p}{,}
                    \PYG{n}{help}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}The initial board state\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZhy{}q\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}\PYGZhy{}\PYGZhy{}quiet\PYGZdq{}}\PYG{p}{,} \PYG{n}{action}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}store\PYGZus{}true\PYGZdq{}}\PYG{p}{,}
                    \PYG{n}{help}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}do not print minmax tree\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{parser}\PYG{o}{.}\PYG{n}{parse\PYGZus{}args}\PYG{p}{()}

\PYG{c+c1}{\PYGZsh{} boolean\PYGZhy{}indexed array to get states compactly and quickly}
\PYG{n}{state\PYGZus{}from\PYGZus{}bool} \PYG{o}{=} \PYG{p}{[}\PYG{n}{State}\PYG{o}{.}\PYG{n}{O\PYGZus{}WIN}\PYG{p}{,} \PYG{n}{State}\PYG{o}{.}\PYG{n}{X\PYGZus{}WIN}\PYG{p}{]}

\PYG{k}{def} \PYG{n+nf}{optimise}\PYG{p}{(}\PYG{n}{evaluations}\PYG{p}{,} \PYG{n}{is\PYGZus{}crosses}\PYG{p}{,} \PYG{n}{minimise}\PYG{p}{):}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    \PYGZdq{}Optimise\PYGZdq{} a sequence of results for a given player. This simultaneously}
\PYG{l+s+sd}{    implements both minimisation and maximisation with a bit of Boolean logic.}
\PYG{l+s+sd}{    It also knows how to short\PYGZhy{}circuit \PYGZhy{} if maximising, a win is known to be the}
\PYG{l+s+sd}{    best possible case and vice verse.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{LOSE\PYGZus{}STATE}\PYG{p}{,} \PYG{n}{WIN\PYGZus{}STATE} \PYG{o}{=} \PYG{n}{state\PYGZus{}from\PYGZus{}bool}\PYG{p}{[}\PYG{n}{minimise} \PYG{o}{\PYGZca{}} \PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{is\PYGZus{}crosses}\PYG{p}{)],} \PYG{n}{state\PYGZus{}from\PYGZus{}bool}\PYG{p}{[}\PYG{n}{minimise} \PYG{o}{\PYGZca{}} \PYG{n}{is\PYGZus{}crosses}\PYG{p}{]}
    \PYG{n}{draw\PYGZus{}seen} \PYG{o}{=} \PYG{n+nb+bp}{False}
    \PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n}{evaluations}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{e} \PYG{o}{==} \PYG{n}{LOSE\PYGZus{}STATE}\PYG{p}{:}
            \PYG{k}{return} \PYG{n}{e}
        \PYG{k}{elif} \PYG{n}{e} \PYG{o}{==} \PYG{n}{State}\PYG{o}{.}\PYG{n}{DRAW}\PYG{p}{:}
            \PYG{n}{draw\PYGZus{}seen} \PYG{o}{=} \PYG{n+nb+bp}{True}
    \PYG{k}{if} \PYG{n}{draw\PYGZus{}seen}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{State}\PYG{o}{.}\PYG{n}{DRAW}
    \PYG{k}{return} \PYG{n}{WIN\PYGZus{}STATE}

\PYG{k}{def} \PYG{n+nf}{generate\PYGZus{}moves}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{is\PYGZus{}crosses}\PYG{p}{):}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Generate possible moves on a board for a certain player. This works by}
\PYG{l+s+sd}{    mutating the actual board array for each possible move, followed by yielding}
\PYG{l+s+sd}{    both the move and the board. This is useful as it allows \PYGZdq{}iteration\PYGZdq{} over}
\PYG{l+s+sd}{    moves, while also being memory\PYGZhy{}efficient (which leads to time efficiency as}
\PYG{l+s+sd}{    there is no allocation overhead).}
\PYG{l+s+sd}{    A finally clause implements the restoration of the board, which guarantees}
\PYG{l+s+sd}{    that the board will retain its state from before after this function exits,}
\PYG{l+s+sd}{    even if the function is interrupted by, for example, a break.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{for} \PYG{n}{ind}\PYG{p}{,} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{board}\PYG{p}{):}
        \PYG{k}{if} \PYG{n}{i} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
            \PYG{k}{try}\PYG{p}{:}
                \PYG{n}{board}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]} \PYG{o}{=} \PYG{n}{is\PYGZus{}crosses}
                \PYG{k}{yield} \PYG{n}{ind}\PYG{p}{,} \PYG{n}{board}
            \PYG{k}{finally}\PYG{p}{:}
                \PYG{n}{board}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb+bp}{None}

\PYG{k}{def} \PYG{n+nf}{evaluate\PYGZus{}board}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{is\PYGZus{}crosses}\PYG{p}{,} \PYG{n}{crosses\PYGZus{}playing}\PYG{p}{,} \PYG{n}{prev\PYGZus{}move}\PYG{p}{,} \PYG{n}{depth}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,}
      \PYG{n}{verbose}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{):}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Evaluate a board\PYGZhy{}state for a given player. This recursively generates moves,}
\PYG{l+s+sd}{    evaluates them and optimises them.}
\PYG{l+s+sd}{    Allows printing diagnostics with the verbosity parameter. It will indent}
\PYG{l+s+sd}{    depending on the current length of the callstack, which helps keep track of}
\PYG{l+s+sd}{    the recursion.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{verbose} \PYG{o+ow}{and} \PYG{k}{print}\PYG{p}{(}\PYG{n}{indent}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Examining as \PYGZob{}\PYGZcb{} \PYGZob{}\PYGZcb{}:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZob{}\PYGZcb{}\PYGZdq{}}
                         \PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{syms}\PYG{p}{[}\PYG{n}{crosses\PYGZus{}playing}\PYG{p}{],} \PYG{n}{depth}\PYG{p}{,}
                            \PYG{n}{indent}\PYG{p}{(}\PYG{n}{strfboard}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{n}\PYG{p}{),} \PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{p}{)),}
                      \PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}} \PYG{o}{*} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{extract\PYGZus{}stack}\PYG{p}{())))}
    \PYG{k}{if} \PYG{n}{is\PYGZus{}run}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{prev\PYGZus{}move}\PYG{p}{,} \PYG{n}{n}\PYG{p}{):}
        \PYG{n}{state} \PYG{o}{=} \PYG{n}{state\PYGZus{}from\PYGZus{}bool}\PYG{p}{[}\PYG{o+ow}{not} \PYG{n}{crosses\PYGZus{}playing}\PYG{p}{]}
        \PYG{n}{verbose} \PYG{o+ow}{and} \PYG{k}{print}\PYG{p}{(}\PYG{n}{indent}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}State here: \PYGZob{}\PYGZcb{}\PYGZdq{}}
                  \PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{state}\PYG{p}{),} \PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}} \PYG{o}{*} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{extract\PYGZus{}stack}\PYG{p}{())))}
        \PYG{k}{return} \PYG{n}{state}
    \PYG{k}{elif} \PYG{n}{depth} \PYG{o}{==} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{board}\PYG{p}{):}
        \PYG{n}{verbose} \PYG{o+ow}{and} \PYG{k}{print}\PYG{p}{(}\PYG{n}{indent}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Draw here\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}} \PYG{o}{*} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{extract\PYGZus{}stack}\PYG{p}{())))}
        \PYG{k}{return} \PYG{n}{State}\PYG{o}{.}\PYG{n}{DRAW}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{optimise}\PYG{p}{(}
                \PYG{p}{(}\PYG{n}{evaluate\PYGZus{}board}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{is\PYGZus{}crosses}\PYG{p}{,} \PYG{o+ow}{not} \PYG{n}{crosses\PYGZus{}playing}\PYG{p}{,}
                                \PYG{n}{move}\PYG{p}{,} \PYG{n}{depth} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{verbose}\PYG{o}{=}\PYG{n}{verbose}\PYG{p}{)}
                   \PYG{k}{for} \PYG{n}{move}\PYG{p}{,} \PYG{n}{board} \PYG{o+ow}{in} \PYG{n}{generate\PYGZus{}moves}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{crosses\PYGZus{}playing}\PYG{p}{)),}
                 \PYG{n}{is\PYGZus{}crosses}\PYG{p}{,} \PYG{o+ow}{not} \PYG{n}{crosses\PYGZus{}playing} \PYG{o}{\PYGZca{}} \PYG{n}{is\PYGZus{}crosses}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}computer\PYGZus{}move}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{is\PYGZus{}crosses}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{verbose}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{):}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Apply board evaluation to all possible moves and}
\PYG{l+s+sd}{    select, in order:}
\PYG{l+s+sd}{    \PYGZhy{} A winning move}
\PYG{l+s+sd}{    \PYGZhy{} A drawing move}
\PYG{l+s+sd}{    \PYGZhy{} Any move (which will be a losing move)}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} optimisation: play here for an empty board, because searching through the}
    \PYG{c+c1}{\PYGZsh{} whole board\PYGZsq{}s tree is known to be unnecessary}
    \PYG{k}{if} \PYG{n+nb}{all}\PYG{p}{(}\PYG{n}{i} \PYG{o+ow}{is} \PYG{n+nb+bp}{None} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{board}\PYG{p}{):}
        \PYG{k}{return} \PYG{l+m+mi}{0}
    \PYG{n}{WIN\PYGZus{}STATE} \PYG{o}{=} \PYG{n}{state\PYGZus{}from\PYGZus{}bool}\PYG{p}{[}\PYG{n}{is\PYGZus{}crosses}\PYG{p}{]}
    \PYG{n}{moves} \PYG{o}{=} \PYG{n}{generate\PYGZus{}moves}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{is\PYGZus{}crosses}\PYG{p}{)}
    \PYG{n}{draw} \PYG{o}{=} \PYG{n+nb+bp}{None}
    \PYG{k}{for} \PYG{n}{move}\PYG{p}{,} \PYG{n}{board} \PYG{o+ow}{in} \PYG{n}{moves}\PYG{p}{:}
        \PYG{n}{ev} \PYG{o}{=} \PYG{n}{evaluate\PYGZus{}board}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{is\PYGZus{}crosses}\PYG{p}{,} \PYG{o+ow}{not} \PYG{n}{is\PYGZus{}crosses}\PYG{p}{,} \PYG{n}{move}\PYG{p}{,}
                            \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{board}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{board}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{n+nb+bp}{None}\PYG{p}{),} \PYG{n}{n}\PYG{p}{,} \PYG{n}{verbose}\PYG{o}{=}\PYG{n}{verbose}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{ev} \PYG{o}{==} \PYG{n}{WIN\PYGZus{}STATE}\PYG{p}{:}
            \PYG{n}{verbose} \PYG{o+ow}{and} \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Win incoming\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{return} \PYG{n}{move}
        \PYG{k}{elif} \PYG{n}{ev} \PYG{o}{==} \PYG{n}{State}\PYG{o}{.}\PYG{n}{DRAW}\PYG{p}{:}
            \PYG{n}{verbose} \PYG{o+ow}{and} \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Draw forcable\PYGZdq{}}\PYG{p}{)}
            \PYG{n}{draw} \PYG{o}{=} \PYG{n}{move}
    \PYG{k}{if} \PYG{n}{draw} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{draw}
    \PYG{k}{return} \PYG{n}{board}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n+nb+bp}{None}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{do\PYGZus{}computer\PYGZus{}move}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{is\PYGZus{}crosses}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{verbose}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{):}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Wraps get\PYGZus{}computer\PYGZus{}move to print some stuff, mutate the board and check for}
\PYG{l+s+sd}{    winning conditions.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{move} \PYG{o}{=} \PYG{n}{get\PYGZus{}computer\PYGZus{}move}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{is\PYGZus{}crosses}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{verbose}\PYG{o}{=}\PYG{n}{verbose}\PYG{p}{)}
    \PYG{n}{board}\PYG{p}{[}\PYG{n}{move}\PYG{p}{]} \PYG{o}{=} \PYG{n}{is\PYGZus{}crosses}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Computer plays at (\PYGZob{}\PYGZcb{}, \PYGZob{}\PYGZcb{})\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{move} \PYG{o}{\PYGZpc{}} \PYG{n}{n}\PYG{p}{,} \PYG{n}{move} \PYG{o}{//} \PYG{n}{n}\PYG{p}{))}
    \PYG{n}{print\PYGZus{}board}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{is\PYGZus{}run}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{move}\PYG{p}{,} \PYG{n}{n}\PYG{p}{):}
        \PYG{k}{raise} \PYG{n}{Win}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}I\PYGZsq{}m sorry, Dave. I\PYGZsq{}m afraid I can\PYGZsq{}t do that.\PYGZdq{}}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{args} \PYG{o}{=} \PYG{n}{get\PYGZus{}args}\PYG{p}{()}
    \PYG{n}{board} \PYG{o}{=} \PYG{n}{args}\PYG{o}{.}\PYG{n}{board}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{isqrt}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{args}\PYG{o}{.}\PYG{n}{board}\PYG{p}{))}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}
    \PYG{n}{print\PYGZus{}board}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}
    \PYG{n}{do\PYGZus{}computer\PYGZus{}move}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{verbose}\PYG{o}{=}\PYG{o+ow}{not} \PYG{n}{args}\PYG{o}{.}\PYG{n}{quiet}\PYG{p}{)}
\end{Verbatim}
