\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Functions implementing grid checks, efficiently.}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{from} \PYG{n+nn}{argparse} \PYG{k+kn}{import} \PYG{n}{ArgumentParser}

\PYG{k+kn}{from} \PYG{n+nn}{base} \PYG{k+kn}{import} \PYG{n}{State}
\PYG{k+kn}{from} \PYG{n+nn}{formatting} \PYG{k+kn}{import} \PYG{n}{get\PYGZus{}board\PYGZus{}template}

\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}args}\PYG{p}{():}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Get size of board}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{parser} \PYG{o}{=} \PYG{n}{ArgumentParser}\PYG{p}{(}\PYG{n}{description}\PYG{o}{=}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}}\PYG{p}{)}
    \PYG{n}{parser}\PYG{o}{.}\PYG{n}{add\PYGZus{}argument}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}n\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{type}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{help}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}size of board to check\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{parser}\PYG{o}{.}\PYG{n}{parse\PYGZus{}args}\PYG{p}{()}

\PYG{k}{def} \PYG{n+nf}{\PYGZus{}make\PYGZus{}groups}\PYG{p}{(}\PYG{n}{n}\PYG{p}{):}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    This function should not be accessed directly \PYGZhy{} use get\PYGZus{}groups.  Construct}
\PYG{l+s+sd}{    the list of \PYGZdq{}groups\PYGZdq{} present on the board \PYGZhy{} rows, columns, diagonals. Groups}
\PYG{l+s+sd}{    are represented as Python ranges because they\PYGZsq{}re all around suitable \PYGZhy{}}
\PYG{l+s+sd}{    efficient, linear etc. Return a list of lists of these groups, where}
\PYG{l+s+sd}{    indexing by board position returns the list of groups that that position is}
\PYG{l+s+sd}{    contained in. This is pretty memory\PYGZhy{}efficient as each actual list is only}
\PYG{l+s+sd}{    stored once, and the remainder of the data structure is primarily pointers.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{rows} \PYG{o}{=} \PYG{p}{([}\PYG{n}{r} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
               \PYG{k}{for} \PYG{n}{r} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i} \PYG{o}{*} \PYG{n}{n}\PYG{p}{,} \PYG{n}{i} \PYG{o}{*} \PYG{n}{n} \PYG{o}{+} \PYG{n}{n}\PYG{p}{),} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i} \PYG{o}{+} \PYG{n}{n} \PYG{o}{**} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)]]}
          \PYG{o}{+} \PYG{p}{[}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{n} \PYG{o}{**} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{n} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{),} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n} \PYG{o}{**} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)])}

    \PYG{k}{return} \PYG{p}{[[}\PYG{n}{r} \PYG{k}{for} \PYG{n}{r} \PYG{o+ow}{in} \PYG{n}{rows} \PYG{k}{if} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{r}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n} \PYG{o}{**} \PYG{l+m+mi}{2}\PYG{p}{)]}

\PYG{c+c1}{\PYGZsh{} The registry for groups}
\PYG{n}{GROUP\PYGZus{}REGISTRY} \PYG{o}{=} \PYG{p}{\PYGZob{}\PYGZcb{}}

\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}groups}\PYG{p}{(}\PYG{n}{n}\PYG{p}{):}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Access a list of groups. This checks if the groups have been generated and}
\PYG{l+s+sd}{    cached already, and if not, does so, caching them in the process, and then}
\PYG{l+s+sd}{    returns.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n}{GROUP\PYGZus{}REGISTRY}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{GROUP\PYGZus{}REGISTRY}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{GROUP\PYGZus{}REGISTRY}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{n}{\PYGZus{}make\PYGZus{}groups}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{GROUP\PYGZus{}REGISTRY}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}

\PYG{k}{def} \PYG{n+nf}{is\PYGZus{}run}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{pos}\PYG{p}{,} \PYG{n}{n}\PYG{p}{):}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Check if one tile is a part of any complete groups.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n+nb}{any}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{board}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{group}\PYG{p}{))} \PYG{o}{==} \PYG{l+m+mi}{1} \PYG{k}{for} \PYG{n}{group} \PYG{o+ow}{in} \PYG{n}{get\PYGZus{}groups}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)[}\PYG{n}{pos}\PYG{p}{])}

\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}state}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{n}\PYG{p}{):}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Get state of board. This function is given no information about position}
\PYG{l+s+sd}{    so is necessarily much slower. If you do know the last played tile, use}
\PYG{l+s+sd}{    is\PYGZus{}run instead, as this only checks all groups pertaining to that tile.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{for} \PYG{n}{pos}\PYG{p}{,} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{board}\PYG{p}{):}
        \PYG{k}{if} \PYG{n}{m} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n+nb+bp}{None}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{is\PYGZus{}run}\PYG{p}{(}\PYG{n}{board}\PYG{p}{,} \PYG{n}{pos}\PYG{p}{,} \PYG{n}{n}\PYG{o}{=}\PYG{n}{n}\PYG{p}{):}
                \PYG{k}{if} \PYG{n}{m}\PYG{p}{:}
                    \PYG{k}{return} \PYG{n}{State}\PYG{o}{.}\PYG{n}{X\PYGZus{}WIN}
                \PYG{k}{return} \PYG{n}{State}\PYG{o}{.}\PYG{n}{O\PYGZus{}WIN}
    \PYG{k}{if} \PYG{n}{board}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{n+nb+bp}{None}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{State}\PYG{o}{.}\PYG{n}{DRAW}
    \PYG{k}{return} \PYG{n}{State}\PYG{o}{.}\PYG{n}{NEUTRAL}

\PYG{k}{def} \PYG{n+nf}{show\PYGZus{}groups}\PYG{p}{(}\PYG{n}{n}\PYG{p}{):}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Demo function which displays each groups using functions from formatting.py.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{board\PYGZus{}temp} \PYG{o}{=} \PYG{n}{get\PYGZus{}board\PYGZus{}template}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{ind}\PYG{p}{,} \PYG{n}{pos} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{get\PYGZus{}groups}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)):}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{ind}\PYG{p}{,} \PYG{n}{pos}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{g} \PYG{o+ow}{in} \PYG{n}{pos}\PYG{p}{:}
            \PYG{n}{dft} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}}\PYG{p}{]} \PYG{o}{*} \PYG{n}{n} \PYG{o}{**} \PYG{l+m+mi}{2}
            \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{g}\PYG{p}{:}
                \PYG{n}{dft}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}G\PYGZdq{}}
            \PYG{n}{dft}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}M\PYGZsq{}}
            \PYG{k}{print}\PYG{p}{(}\PYG{n}{board\PYGZus{}temp}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{o}{*}\PYG{n}{dft}\PYG{p}{),} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{args} \PYG{o}{=} \PYG{n}{get\PYGZus{}args}\PYG{p}{()}
    \PYG{n}{show\PYGZus{}groups}\PYG{p}{(}\PYG{n}{args}\PYG{o}{.}\PYG{n}{n}\PYG{p}{)}
\end{Verbatim}
